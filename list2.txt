const TelegramApi = require('node-telegram-bot-api');
const { menu, spherechild, sphereolds, test1, years, years9, years6, years13, years18, district, getTaro, category, limit, consult, back } = require('./options');
require('dotenv').config();
const UserModel = require('./models.js')
const token = process.env.TOKEN;
const sequelize = require('./db.js')
const chalk = require('chalk')

const bot = new TelegramApi(token, { polling: true })
const { getRandomCard } = require('./getRandomCard.js');
const { sendInvoice, handlePreCheckoutQuery, handleSuccessfulPayment } = require('./payments.js');

const start = async () => {

    try {
        await sequelize.authenticate();
        await sequelize.sync();
        console.log(chalk.magenta('Connected to database...'))

    } catch (error) {
        console.error(chalk.red('–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î'), error);
    }

    bot.setMyCommands([
        { command: '/start', description: "–ù–∞—á–∞–ª—å–Ω–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ" },
       // { command: '/pay', description: "–ó–∞–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—é" },
    ]);

    const userStates = {};

    bot.on('message', async msg => {
        try {
            const username = msg.chat.username;
            const text = msg.text;
            const firstName = msg.chat.first_name;
            const chatId = msg.chat.id;
            const messageId = msg.message_id;
            const userId = msg.from.id;
            const currentTime = Date.now();
            const oneDay = 24 * 60 * 60 * 1000;

            if (text === '/pay') {

                await sendInvoice(bot, chatId);
            }

            const user = await UserModel.findOne({where:{chatId:chatId }})
            if (text != '/start' && text != '/pay' && user.invoiceMessageId) {
                var result = text.replace(/[\.\/_*[\]()~`>#+\-=|{}!\\]/g, '\\$&');
                await bot.sendMessage(chatId, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å [" + username + " " + firstName + "](t.me://user?id=" + userId + ")" + " *–æ–ø–ª–∞—Ç–∏–ª —Å—á–µ—Ç*\n" + "\n –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\n_"  +result + "_", { parse_mode: 'MarkdownV2' })
                await bot.sendMessage(chatId,"–û—Ç–ª–∏—á–Ω–æ, –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è —Å –í–∞–º–∏ —Å–≤—è–∂–µ—Ç—Å—è –Ω–∞—à —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç! ")
                await user.update({ invoiceMessageId: 0 })
                await user.save()
            }
            console.log(msg);

            if (text === '/start') {
                const user = await UserModel.findOne({ where:{chatId:chatId }})
                console.log(user)
                if (user=== null) {
                    await UserModel.create({chatId, firstName, username });
                    const table = await UserModel.findAll()
                    console.log(table)
                    await bot.sendMessage(chatId, "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –ö–∞—Ä—Ç–∞ –¥–Ω—è, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –Ω—É–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª", menu);
                }


                // // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞               
                // else if ((currentTime - user.lastRequest) < oneDay) {

                //     const lastRequestTime = user.lastRequest;

                //     const timeLeft = oneDay - (currentTime - lastRequestTime);
                //     const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
                //     const minutesLeft = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
                //     const secondsLeft = Math.floor((timeLeft % (60 * 1000)) / 1000);

                //     await bot.sendMessage(chatId, `–í—ã —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ —Ä–∞—Å–∫–ª–∞–¥ —Å–µ–≥–æ–¥–Ω—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∑–∞–≤—Ç—Ä–∞ —á–µ—Ä–µ–∑ ${hoursLeft} —á–∞—Å–æ–≤ ${minutesLeft} –º–∏–Ω—É—Ç ${secondsLeft} —Å–µ–∫—É–Ω–¥.`, consult);
                // }
                // else {
                //     await bot.sendMessage(chatId, "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –ö–∞—Ä—Ç–∞ –¥–Ω—è, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –Ω—É–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª", menu);
                // }
            }
        } catch (error) {
            console.log(error)
        } // await bot.deleteMessage(chatId, messageId);
    });




    bot.on('callback_query', async msg => {
        try {
            const data = msg.data;
            const chatId = msg.message.chat.id;
            const messageId = msg.message.message_id;
            const userId = msg.from.id;
            const currentTime = Date.now();
            const oneDay = 24 * 60 * 60 * 1000;

            console.log(msg)



            if (data === 'getTaro') {
                let pass = await bot.getChatMember("@tkkd13", msg.from.id);

                if (pass.status === "left") {
                    await bot.editMessageText("–¢—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ –º–æ–π –∫–∞–Ω–∞–ª", {
                        chat_id: chatId,
                        message_id: messageId,
                        reply_markup: menu.reply_markup
                    });


                    // await bot.deleteMessage(chatId, messageId);
                } else {
                    const user = await UserModel.findOne({ where:{chatId:chatId } })

                    if (user.lastRequest && (currentTime - user.lastRequest) < oneDay) {

                        await bot.editMessageText("–í—ã —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ —Ä–∞—Å–∫–ª–∞–¥ —Å–µ–≥–æ–¥–Ω—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∑–∞–≤—Ç—Ä–∞.", {
                            chat_id: chatId,
                            message_id: messageId,
                            reply_markup: consult.reply_markup
                        })

                    }
                    else {
                        await bot.editMessageText("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é üìÇ", {
                            chat_id: chatId,
                            message_id: messageId,
                            reply_markup: category.reply_markup
                        });
                    }
                }
            }

            const categories = ['category1', 'category2'];
            if (categories.includes(data)) {

                if (!userStates[userId]) {
                    userStates[userId] = {};
                }

                userStates[userId] = { category: data };

                await bot.editMessageText("–ü–µ—Ä–µ—Ç–∞—Å–æ–≤—ã–≤–∞—é –∫–æ–ª–æ–¥—É...", {
                    chat_id: chatId,
                    message_id: messageId
                });

                await bot.sendChatAction(chatId, "typing")
                await new Promise(resolve => setTimeout(resolve, 1000));
                await bot.editMessageText("–í—ã–±–µ—Ä–∏ –æ–¥–Ω—É –∫–∞—Ä—Ç—É ‚ô†", {
                    chat_id: chatId,
                    message_id: messageId,
                    reply_markup: getTaro.reply_markup
                });
            }

            if (data === "/") {
                const user = await UserModel.findOne({ where:{chatId:chatId }})
                // user.lastRequest = currentTime;
                //     await user.update({lastRequest});

                if (user.lastRequest && (currentTime - user.lastRequest) < oneDay) {
                    const timeLeft = oneDay - (currentTime - user.lastRequest);
                    const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
                    const minutesLeft = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
                    const secondsLeft = Math.floor((timeLeft % (60 * 1000)) / 1000);

                    await bot.editMessageText("–í—ã —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ —Ä–∞—Å–∫–ª–∞–¥ —Å–µ–≥–æ–¥–Ω—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∑–∞–≤—Ç—Ä–∞.", {
                        chat_id: chatId,
                        message_id: messageId,
                        reply_markup: consult.reply_markup
                    });

                    await bot.sendMessage(chatId, `–û—Å—Ç–∞–ª–æ—Å—å –≤—Ä–µ–º–µ–Ω–∏${hoursLeft} —á–∞—Å–æ–≤ ${minutesLeft} –º–∏–Ω—É—Ç ${secondsLeft} —Å–µ–∫—É–Ω–¥`)
                    return;
                }

                else {

                    await bot.editMessageText("–î–æ—Å—Ç–∞—é –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã...", {
                        chat_id: chatId,
                        message_id: messageId
                    });
                    await bot.sendChatAction(chatId, "upload_photo");
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    const { category } = userStates[userId];
                    console.log(category)
                    user.lastRequest = currentTime;
                    await user.save();
                    const { cardImage, predictionText } = getRandomCard(category);
                    await bot.sendPhoto(chatId, cardImage);
                    await bot.sendMessage(chatId, predictionText);
                    user.lastRequest = currentTime;
                    await user.save();
                    await bot.sendMessage(chatId, "–ó–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—É –ª–∏—á–Ω–æ –∏–ª–∏ –ø—Ä–∏—Ö–æ–¥–∏ –∑–∞–≤—Ç—Ä–∞ –∏ –≥–∞–¥–∞–π —Å–Ω–æ–≤–∞! üåô", consult)
                }


            }
            if (data === 'needConsult') {
                await bot.editMessageText("üí´–î–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ª–∏—á–Ω—É—é –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—é —É —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞üßù‚Äç‚ôÄÔ∏èüí¨ –∏ –æ—Ç–≤–µ—Ç –Ω–∞ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–ø–ª–∞—Ç–∏—Ç—å 60 —Ä", {
                    chat_id: chatId,
                    message_id: messageId,
                    reply_markup: back.reply_markup
                });
                await sendInvoice(bot, chatId);
                if (!userStates[userId]) {
                    userStates[userId] = {};
                }
            }
            if (data === 'needInfo') {
                await bot.editMessageText("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–∞–≤–∏–ª–∞—Ö –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è –∏—Ç–ø –∏—Ç–¥...", {
                    chat_id: chatId,
                    message_id: messageId,
                    reply_markup: back.reply_markup
                });
            }
            if (data === 'back') {
                await bot.editMessageText("–ó–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—É –ª–∏—á–Ω–æ –∏–ª–∏ –ø—Ä–∏—Ö–æ–¥–∏ –∑–∞–≤—Ç—Ä–∞ –∏ –≥–∞–¥–∞–π —Å–Ω–æ–≤–∞! üåô", {
                    chat_id: chatId,
                    message_id: messageId,
                    reply_markup: consult.reply_markup
                });
            }

            if (data === 'pay') {
                await sendInvoice(bot, chatId);
            }

        } catch (error) {
            console.error(error);
        }
    });


    bot.on('pre_checkout_query', async query => {
        try {
            await handlePreCheckoutQuery(bot, query);
        } catch (error) {
            console.error(error);
        }

    });
    bot.on('successful_payment', async msg => {
        try {
            const chatId = msg.chat.id;
            const messageId = msg.message_id;
            await handleSuccessfulPayment(bot, msg);
            const user = await UserModel.findOne({ where:{chatId:chatId }})
            user.invoiceMessageId = messageId;
            await user.save()
        } catch (error) {
            console.error(error);
        }
    });
    console.log(chalk.cyan('Bot is running...'));

}
start()
