const TelegramApi = require('node-telegram-bot-api');
const { menu, spherechild, sphereolds, test1, years, years9, years6, years13, years18, district, getTaro, category, limit, consult, back, paidButton, paidConsult, menuConst } = require('./options');
require('dotenv').config();
const UserModel = require('./models.js')
const token = process.env.TOKEN;
const sequelize = require('./db.js')


const bot = new TelegramApi(token, { polling: true })
const { getRandomCard } = require('./getRandomCard.js');
const { sendInvoice, handlePreCheckoutQuery, handleSuccessfulPayment } = require('./payments.js');


const start = async () => {

    try {
        await sequelize.authenticate();
        await sequelize.sync();
        console.log('Connected to database...')

    } catch (error) {
        console.error(chalk.red('–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î'), error);
    }

    bot.setMyCommands([
        { command: '/start', description: "–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ –∑–∞–Ω–æ–≤–æ" },
      
    ]);

    const userStates = {};

    bot.on('message', async msg => {
        try {
            const username = msg.chat.username;
            const text = msg.text;
            const firstName = msg.chat.first_name;
            const chatId = msg.chat.id;
            const messageId = msg.message_id;
            
            if (text === '/pay') {

                await sendInvoice(bot, chatId);
            }


            if (text === '/start') {
                const user = await UserModel.findOrCreate({ where: { chatId: chatId }, defaults: { chatId: chatId, firstName: firstName, username: username }})
                const table = await UserModel.findAll()
                let pass = await bot.getChatMember("@tkkd13", msg.from.id);
                if(pass.status==='left'){
                     await bot.sendMessage(chatId, "–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –Ω—É–∂–Ω–æ" +" *–ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è* "+ "–Ω–∞ –º–æ–π –∫–∞–Ω–∞–ª",{parse_mode:'MarkdownV2',reply_markup:menu.reply_markup});
                }
                else if(messageId!= null){ 
                await bot.sendMessage(chatId,"–ß—Ç–æ —Ç–µ–±—è –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç —Å–µ–≥–æ–¥–Ω—è?",menuConst );
                await bot.sendSticker(chatId, "./sticker.webp")
                   
                }
                
            }
            const user = await UserModel.findOne({ where: { chatId: chatId } });

            if(user.consultMessageId=1 && text!='/start'){

                const dateRegex = /^(0?[1-9]|[12][0-9]|3[01])\.(0?[1-9]|1[012])\.(19|20)\d\d$/;
                if (dateRegex.test(text)) {
                    // –†–∞–∑–±–∏–≤–∞–µ–º —Å—Ç—Ä–æ–∫—É –Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
                    const [day, month, year] = text.split('.').map(Number);
            
                    // –°—É–º–º–∏—Ä—É–µ–º —Ü–∏—Ñ—Ä—ã
                    let sum = [...(day.toString() + month.toString() + year.toString())].reduce((acc, digit) => acc + parseInt(digit), 0);
            
                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —á–∏—Å–ª–æ —Å—É–¥—å–±—ã
                    while (sum > 9) {
                        sum = sum.toString().split('').reduce((acc, digit) => acc + parseInt(digit), 0);
                    }
            
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                    bot.sendMessage(chatId, `–í–∞—à–µ —á–∏—Å–ª–æ —Å—É–¥—å–±—ã ${sum}!\n –£–∑–Ω–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω–µ–µ -->`,paidConsult);
            
                    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º consultMessageId
                    user.consultMessageId = 0;
                    await user.save();
                } else {
                    // –ï—Å–ª–∏ —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã –Ω–µ–≤–µ—Ä–Ω—ã–π, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
                    bot.sendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì (–Ω–∞–ø—Ä–∏–º–µ—Ä, 11.02.1986).');
                }
            }

        } catch (error) {
            console.log(error)
        } 
    });




    bot.on('callback_query', async msg => {
        try {
            const data = msg.data;
            const chatId = msg.message.chat.id;
            const messageId = msg.message.message_id;
            const userId = msg.from.id;
            const currentTime = Date.now();
            const oneDay = 24 * 60 * 60 * 1000;
            console.log(msg)

            if (data === 'GETTARO') {
                await bot.deleteMessage(chatId,messageId)
                let pass = await bot.getChatMember("@tkkd13", msg.from.id);

                if (pass.status === "left") {
                    await bot.sendMessage(chatId,"–¢—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ –º–æ–π –∫–∞–Ω–∞–ª ‚òπ",menu );
                } else {
                 
                        await bot.sendMessage(chatId,"–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é üìÇ",category);
                    
                }
            }


            if (data === 'getTaro') {
                let pass = await bot.getChatMember("@tkkd13", msg.from.id);

                if (pass.status === "left") {
                    await bot.editMessageText("–¢—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ –º–æ–π –∫–∞–Ω–∞–ª ‚òπ", {
                        chat_id: chatId,
                        message_id: messageId,
                        reply_markup: menu.reply_markup
                    });

                }
                else {
                    await bot.editMessageText("üìÇ –í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é ", {
                        chat_id: chatId,
                        message_id: messageId,
                        reply_markup: category.reply_markup
                    });
                }

            }

            const categories = ['category1', 'category2', 'category2', 'category3'];
            if (categories.includes(data)) {
                if (!userStates[userId]) {
                    userStates[userId] = {};
                }

                userStates[userId] = { category: data };

                await bot.sendMessage(chatId,"–ü–µ—Ä–µ—Ç–∞—Å–æ–≤—ã–≤–∞—é –∫–æ–ª–æ–¥—É...")
                

                await bot.sendChatAction(chatId, "typing")
                await new Promise(resolve => setTimeout(resolve, 1000));
                await bot.sendMessage(chatId,"–í—ã–±–µ—Ä–∏ –æ–¥–Ω—É –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã üëá",getTaro);
            }


            if (data === "/" && userStates[userId] && userStates[userId].category === "category1") {

                const user = await UserModel.findOne({ where: { chatId: chatId } })
              

                if (user.lastRequestCardDay && (currentTime - user.lastRequestCardDay) < oneDay) {
                    const timeLeft = oneDay - (currentTime - user.lastRequestCardDay);
                    const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
                    const minutesLeft = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
                    const secondsLeft = Math.floor((timeLeft % (60 * 1000)) / 1000);

                    await bot.editMessageText("‚è≥ –í—ã —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ –∫–∞—Ä—Ç—É —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–≥–æ –¥–Ω—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∑–∞–≤—Ç—Ä–∞. \n" + `\n–û—Å—Ç–∞–ª–æ—Å—å –≤—Ä–µ–º–µ–Ω–∏ ${hoursLeft} —á–∞—Å–∞ ${minutesLeft} –º–∏–Ω—É—Ç ${secondsLeft} —Å–µ–∫—É–Ω–¥\n` , {
                        chat_id: chatId,
                        message_id: messageId,
                        reply_markup: consult.reply_markup
                    });

                    
                } else {

                    await bot.sendMessage(chatId,"–î–æ—Å—Ç–∞—é –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã...");
                    await bot.sendChatAction(chatId, "upload_photo");
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    const { category } = userStates[userId];
                    console.log(category)
                    const { cardImage, predictionText } = getRandomCard(category);
                    await bot.sendPhoto(chatId, cardImage);
                    await bot.sendMessage(chatId, predictionText, consult);
                    user.lastRequestCardDay = currentTime;
                    await user.save();
                   
                }



            }

            if (data === "/" && userStates[userId] && userStates[userId].category === "category2") {

                const user = await UserModel.findOne({ where: { chatId: chatId } });

                if (user.quantityAnswersYoN < 2 && (currentTime - user.lastRequestYoN) > oneDay) {
                    console.log(user.quantityAnswersYoN + "--------------------------------------------------------") 
                    await bot.sendMessage(chatId,"–î–æ—Å—Ç–∞—é –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã...");
                    await bot.sendChatAction(chatId, "upload_photo");
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    const { category } = userStates[userId];
                    console.log(category)
                    const { cardImage, predictionText } = getRandomCard(category);
                    await bot.sendPhoto(chatId, cardImage);
                    await bot.sendMessage(chatId, predictionText);
                    user.quantityAnswersYoN += 1;
                    await user.save();

                    await bot.sendMessage(chatId, "–ö–∞—Ä—Ç–∞ –Ω–æ–º–µ—Ä:  " + user.quantityAnswersYoN + " üåô", consult)

                } else {
                    const timeLeft = oneDay - (currentTime - user.lastRequestCardDay);
                    const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
                    const minutesLeft = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
                    const secondsLeft = Math.floor((timeLeft % (60 * 1000)) / 1000);
                    await bot.editMessageText("‚è≥ –í—ã —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ 3 –æ—Ç–≤–µ—Ç–∞ —Å–µ–≥–æ–¥–Ω—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∑–∞–≤—Ç—Ä–∞. \n" + `\n–û—Å—Ç–∞–ª–æ—Å—å –≤—Ä–µ–º–µ–Ω–∏ ${hoursLeft} —á–∞—Å–∞ ${minutesLeft} –º–∏–Ω—É—Ç ${secondsLeft} —Å–µ–∫—É–Ω–¥\n`, {
                        chat_id: chatId,
                        message_id: messageId,
                        reply_markup: consult.reply_markup
                    });
                }
                
                if (user.quantityAnswersYoN === 2 && (currentTime - user.lastRequestYoN) > oneDay) {
                    await bot.sendMessage(chatId,"–î–æ—Å—Ç–∞—é –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã...");
                    await bot.sendChatAction(chatId, "upload_photo");
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    const { category } = userStates[userId];
                    console.log(category)
                    const { cardImage, predictionText } = getRandomCard(category);
                    await bot.sendPhoto(chatId, cardImage);
                    await bot.sendMessage(chatId, predictionText);
                    user.quantityAnswersYoN += 1;
                    await user.save();
                    const timeLeft = oneDay - (currentTime - user.lastRequestCardDay);
                    const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
                    const minutesLeft = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
                    const secondsLeft = Math.floor((timeLeft % (60 * 1000)) / 1000);

                    await bot.sendMessage(chatId,"‚è≥ –≠—Ç–æ –±—ã–ª 3 –æ—Ç–≤–µ—Ç –Ω–∞ –≤–∞—à –≤–æ–ø—Ä–æ—Å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∑–∞–≤—Ç—Ä–∞." + `\n–û—Å—Ç–∞–ª–æ—Å—å –≤—Ä–µ–º–µ–Ω–∏ ${hoursLeft} —á–∞—Å–∞ ${minutesLeft} –º–∏–Ω—É—Ç ${secondsLeft} —Å–µ–∫—É–Ω–¥\n`,consult )
                  
                } 

                if (user.quantityAnswersYoN === 3) { 

                    user.quantityAnswersYoN = 0;
                    user.lastRequestYoN = currentTime;
                    await user.save();
                }
            }

         
     

            if (data === "/" && userStates[userId] && userStates[userId].category === "category3") {
                const user = await UserModel.findOne({ where: { chatId: chatId } })
                await user.update({PaidCategory: userStates[userId].category})
                await user.save()

                    await bot.sendMessage(chatId,"–î–æ—Å—Ç–∞—é –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã...");  
    
                    await bot.sendChatAction(chatId, "upload_photo");
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    await bot.sendMessage(chatId,"–í—ã–∫–ª–∞–¥—ã–≤–∞—é 1 –∫–∞—Ä—Ç—É ");  
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    await bot.sendMessage(chatId,"–ü—Ä–µ–¥—Å—Ç–∞–≤—å —Ç–æ–≥–æ –æ –∫–æ–º —Ö–æ—á–µ—à—å –∑–Ω–∞—Ç—å .... ");  
                    await bot.sendChatAction(chatId, "upload_photo");
                    await new Promise(resolve => setTimeout(resolve, 3000));
                        
                    const category = user.PaidCategory
                    console.log(category)
                    const { cardImage, predictionText } = getRandomCard(category);
                    await bot.sendPhoto(chatId, cardImage);
                    await bot.sendMessage(chatId, predictionText, consult);
                    await user.update({ invoiceMessageId: 0 })
                    await user.update({ PaidCategory: 0 })
                    await user.save();
                  
                   
                }

            if (data === 'category4') {
                const user = await UserModel.findOne({ where: { chatId: chatId } })
                await user.update({consultMessageId: 1})
                await user.save()
                await bot.sendMessage(chatId,"–ß—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å —á–∏—Å–ª–æ —Å—É–¥—å–±—ã –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ –¥–∞—Ç—É —Å–≤–æ–µ–≥–æ —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ 25.08.1999");  
            }

        } catch (error) {
            console.error(error);
        }
    });


    bot.on('pre_checkout_query', async query => {
        try {
            await handlePreCheckoutQuery(bot, query);
        } catch (error) {
            console.error(error);
        }

    });
    bot.on('successful_payment', async msg => {
        try {
             const chatId = msg.chat.id;
             const messageId = msg.message_id;
            await bot.deleteMessage(chatId,messageId-1)
            
            await handleSuccessfulPayment(bot, msg);
            const user = await UserModel.findOne({ where: { chatId: chatId } })
            user.invoiceMessageId = Date.now();
            await user.save()

        } catch (error) {
            console.error(error);
        }
    });
    console.log('Bot is running...');

}
start()
